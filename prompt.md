## Задача: реализовать парсер рецептов для сайта thefrenchcookingacademy.com

Нужно реализовать новый парсер для сайта **thefrenchcookingacademy.com**.  
Парсер должен анализировать HTML‑страницы рецептов и извлекать данные в JSON в едином формате, который уже используется в проекте (как в парсере **allrecipes**).

---

### Контекст репозитория

- Язык проекта: Python.
- Парсеры рецептов находятся в директории: `extractor/`.
- Есть уже реализованный парсер для **allrecipes** — по нему нужно ориентироваться:
  - базовый класс парсера;
  - структура возвращаемого JSON;
  - единый стиль кода (типизация, логирование и т.д.).

**Важно:** новый парсер должен вести себя максимально похоже на существующие (особенно на allrecipes) и быть прозрачно интегрируемым в текущий пайплайн.

---

### Входные данные

В репозитории уже сохранены примеры (директория `preprocessed/thefrenchcookingacademy_com`):

- HTML‑файлы страниц рецептов сайта **thefrenchcookingacademy.com**
- Соответствующие им JSON‑файлы с уже извлечёнными данными (эталон)

ВАЖНО:

- JSON‑файлы — это **только эталон / пример правильного результата**.
- **Их НЕЛЬЗЯ использовать напрямую в логике парсера**:
  - нельзя парсить JSON вместо HTML;
  - нельзя «подсматривать» значения из JSON в рантайме.
- JSON‑файлы нужны только для того, чтобы:
  - сверить корректность новой реализации;
  - убедиться, что структура и значения максимально совпадают.

---

### Требования к парсеру

#### 1. Файл и класс

- Создать новый модуль:

  - `extractor/thefrenchcookingacademy_com.py`

- В этом модуле реализовать класс парсера для **thefrenchcookingacademy.com**.
- Структура парсера должна:
  - соответствовать структуре парсера для **allrecipes**;
  - **наследоваться от того же базового класса**, что и парсер allrecipes  
    (`BaseExtractor`).
- Новый класс должен реализовать **те же публичные методы**, что и парсер allrecipes  
  (`extract_all()` - самый основной метод).

#### 2. Поведение парсера

- Парсер должен принимать HTML‑страницу рецепта:
  - уже реализовано в базовом классе, базовый класс BaseRecipeExtractor принимает путь к HTML файлу как строку,
- На выходе в методе extract_all() парсер должен **возвращать словарь (dict) / JSON‑совместимую структуру** с данными рецепта.
- Извлечение данных должно опираться на реальную HTML‑структуру **thefrenchcookingacademy.com**:
  - теги,
  - классы,
  - атрибуты,
  - возможный `microdata` / `JSON‑LD` и т.д.
- Логику парсинга необходимо строить **исключительно по HTML**, а не по структуре эталонного JSON.

---

### 3. Структура выходного JSON

Выходные данные парсера должны содержать **все** следующие поля (как в allrecipes), даже если в конкретном рецепте они отсутствуют:

- `dish_name`
- `description`
- `ingredient`
- `step_by_step`
- `nutrition_info`
- `category`
- `prep_time`
- `cook_time`
- `total_time`
- `servings`
- `difficulty_level`
- `rating`
- `notes`

**Обязательные правила:**

- Все перечисленные поля **обязаны присутствовать** в итоговом dict/JSON.
- Если значение не найдено на странице, оно **должно быть `None`**, а не отсутствовать в объекте.

**Форматы полей (ориентироваться на реализацию allrecipes):**

- `dish_name`:  
  Строка — название блюда.

- `description`:  
  Строка — краткое текстовое описание рецепта (анонс/intro).

- `ingredient`:  
  Список ингредиентов.  
  Формат каждого элемента: **словарь** с полями:
  - `name`: строка — название ингредиента (без количества);
  - `amount`: строка или число — количество (как представлено на сайте, можно нормализовать при необходимости);
  - `unit`: строка — единица измерения (например, `"g"`, `"ml"`, `"tbsp"`, `"cup"` и т.п.), если можно выделить.
  
  Пример структуры:
  ```json
  "ingredient": [
    {"name": "flour", "amount": "200", "unit": "g"},
    {"name": "butter", "amount": "50", "unit": "g"}
  ]
  ```

- `step_by_step`:  
  - строка со всеми щагами из рецепта

- `nutrition_info`:  
  Словарь с данными о питательной ценности формат kkal Б/Ж/У, например 130kkal; 10/12/20:

- `category`:  
  Строка или список строк — тип блюда / кухонная категория (например, `"Dessert"`, `"French"`, `"Main Course"`).

- `prep_time`:  
  Время подготовки в **минутах** (целое число, без указания единиц).  
  Пример: `150`.

- `cook_time`:  
  Время готовки в **минутах** (целое число, без указания единиц).  
  Пример: `45`.

- `total_time`:  
  Общее время приготовления в **минутах** (целое число, без указания единиц).  
  Пример: `195`.

- `servings`:  
  Строка — количество порций как оно представлено на сайте (например, `"4"`, `"2"`).  

- `difficulty_level`:  
  Строка — уровень сложности:
  - например: `"easy"`, `"medium"`, `"hard"`,  
  - либо локализованные значения, если они явно указаны на сайте.

- `rating`:  
  Числовой рейтинг (float/Decimal) или `None`, если оценки нет.

- `notes`:  
  Дополнительные заметки/комментарии к рецепту:
  - строка

---

### 4. Сравнение с эталонным JSON

После реализации парсера нужно:

1. Для каждого HTML‑примера из `preprocessed/thefrenchcookingacademy_com`:
   - прогнать новый парсер;
   - получить результат в виде JSON/dict.

2. Сравнить результат с эталонным JSON:
   - структура (набор полей) должна совпадать;
   - значения полей — максимально близки по смыслу;
   - допустимы только косметические отличия:
     - пробелы,
     - переносы строк,
     - незначительные различия в форматировании текста.

3. Убедиться, что **во всех случаях**:
   - отсутствующие на странице данные заполняются `None`;
   - формат типов (списки/строки/числа/словарь) совпадает с тем, что ожидает остальной код (см. allrecipes).

---

### 5. Технические детали реализации

- Использовать те же библиотеки и подходы к парсингу HTML, что и в остальной части проекта.
- Соблюдать:
  - типизацию (type hints),
  - стиль логирования (logging),
  - структуру классов и методов, принятую в проекте.
- По возможности делать парсер устойчивым к изменению верстки:
  - использовать стабильные селекторы (`data-*` атрибуты, семантические блоки, JSON‑LD),
  - избегать хрупких цепочек CSS‑классов.

- Обработка ошибок:
  - если структура страницы неожиданно изменилась или отсутствует часть данных, логировать проблему;
  - возвращать `None` в соответствующих полях, **не падать с исключением**.

---

### Ветка разработки и Pull Request

- Работать следует в отдельной ветке, например:
  - `'feature/thefrenchcookingacademy-parser`
- Целевая ветка для Pull Request:
  - `feature/copilot-issue`.
- В PR указать:
  - ссылку на этот issue;
  - краткое описание реализованного парсера;
  - список файлов, затронутых изменениями (в первую очередь `extractor/thefrenchcookingacademy_com.py`);

---

### Критерии готовности задачи

1. В файле `extractor/thefrenchcookingacademy_com.py` создан класс парсера для **thefrenchcookingacademy.com**, наследующий базовый класс (как парсер allrecipes).
2. Метод(ы) парсера:
   - принимают HTML‑страницу рецепта thefrenchcookingacademy.com (путь к файлу, уже реализовано в базовом классе, нужно релизвоать только остальные методы),
   - возвращают JSON/словарь со **всеми полями**, перечисленными выше,
   - заполняют отсутствующие данные значением `None`.
3. Формат выходного JSON **строго совместим** с форматом парсера allrecipes (по полям и типам данных).
4. Для предоставленных HTML‑примеров результат максимально близок к эталонным JSON‑файлам.
5. Парсер **не использует эталонные JSON‑файлы как источник данных**, а работает только с HTML.
6. Код следует общему стилю проекта, покрыт базовой обработкой ошибок и не ломает существующий пайплайн.